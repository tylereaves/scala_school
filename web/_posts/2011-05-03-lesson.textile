---
permalink: collections.html
title: Collections
layout: post
desc: Lists, Maps, functional combinators (map, foreach, filter, zip, folds)
---

This lesson covers:
* Lists
* Maps
* Sets
* Tuples
* functional combinators
** map
** foreach
** filter
** zip
** foldRight and foldLeft
** flatMap

   h2. Basic Datastructures

h3. Lists

{% highlight scala %}
val numbers = List(1, 2, 3, 4)
numbers: List[Int] = List(1, 2, 3, 4)
{% endhighlight %}

h3. Sets

Sets have no duplicates

{% highlight scala %}
scala> Set(1, 1, 2)
res0: scala.collection.immutable.Set[Int] = Set(1, 2)
{% endhighlight %}

h3. Tuple

Tuples are used for grouping together simple logical collections of
items without using a class.

{% highlight scala %}
scala> val hostPort = ("localhost", 80)
hostPort: (String, Int) = (localhost, 80)
{% endhighlight %}

Unlike case classes, they don't have named accessors, instead they have accessors that are named by their position and is 1-based rather than 0-based.

{% highlight scala %}
scala> hostPort._1
res0: String = localhost

scala> hostPort._2
res1: Int = 80
{% endhighlight %}

Tuples fit with pattern matching nicely.

{% highlight scala %}
hostPort match {
  case ("localhost", port) => ...
  case (host, port) => ...
}
{% endhighlight %}

Tuple has some special sauce for simply making Tuples of 2 values: <code>-></code>

{% highlight scala %}
scala> 1 -> 2
res0: (Int, Int) = (1,2)
{% endhighlight %}

h3. Maps

It can hold basic datatypes.

{% highlight scala %}
Map(1 -> 2)
Map("foo" -> "bar")
{% endhighlight %}

This looks like special syntax but remember back to our discussion of Tuple that <code>-></code> can be use to create Tuples.

Map() also uses that variable argument syntax we learned back in Lesson #1: <code>Map(1 -> "one", 2 -> "two")</code> which expands into <code>Map((1, "one"), (2, "two"))</code> with the first element being the key and the second being the value of the Map.

Maps can themselves contain Maps or even functions as values.

{% highlight scala %}
Map(1 -> Map("foo" -> "bar"))
{% endhighlight %}

{% highlight scala %}
Map("timesTwo" -> timesTwo(_))
{% endhighlight %}

h3. Option

<code>Option</code> is a container that may or may not hold something.

The basic interface for Option looks like:

<code>
trait Option[T] {
  def isDefined: Boolean
  def get: T
  def getOrElse(t: T): T
}
</code>

Option itself is generic and has two subclasses: <code>Some[T]</code> or <code>None</code>

Let's look at an example of how Option is used:

<code>Map.get</code> uses <code>Option</code> for it's return type. Option signifies to you that the method might not be able to return what you're asking for and that you should be prepared for that.

{% highlight scala %}
scala> val numbers = Map(1 -> "one", 2 -> "two")
numbers: scala.collection.immutable.Map[Int,String] = Map((1,one), (2,two))

scala> numbers.get(2)
res0: Option[java.lang.String] = Some(two)

scala> numbers.get(3)
res1: Option[java.lang.String] = None
{% endhighlight %}

So now our data appears trapped in this <code>Option</code>. How do we work with it?

A first instinct might be to do something conditionally based on the <code>isDefined</code> method.

<code>
// We want to multiply the number by two, otherwise return 0.
val result = if (res1.isDefined()) {
  res1.get * 2
} else {
  0
}
</code>

We would suggest that you use either <code>getOrElse</code> or pattern matching to work with this result.

<code>getOrElse</code> lets you easily define a default value.

<code>
val result = res1.getOrElse(0) * 2
</code>

Pattern matching fits naturally with <code>Option</code>.

<code>
val result = res1 match {
  case Some(n) => n * 2
  case None => 0
}
</code>

h2. Functional Combinators

Combinators are so-called because they are meant to be combined. The output of one function is often suitable as the input for another.

The most common use is on the standard data structures.

h4. map

Evaluates a function over each element in the list, returning a list with the same number of elements.

{% highlight scala %}
scala> numbers.map((i: Int) => i * 2)
res0: List[Int] = List(2, 4, 6, 8)
{% endhighlight %}

or pass in a partially evaluated function

{% highlight scala %}

scala> def timesTwo(i: Int): Int = i * 2
timesTwo: (i: Int)Int

scala> numbers.map(timesTwo _)
res0: List[Int] = List(2, 4, 6, 8)
{% endhighlight %}

h4. foreach

foreach is like map but returns nothing. foreach is intended for side-effects only.

{% highlight scala %}
scala> numbers.foreach((i: Int) => i * 2)
{% endhighlight %}

returns nothing.

You can try to store the return in a value but it'll be of type Unit (i.e. void)

{% highlight scala %}
scala> val doubled = numbers.foreach((i: Int) => i * 2)
doubled: Unit = ()
{% endhighlight %}

h4. filter

removes any elements where the function you pass in evaluates to false.  Functions that return a Boolean are often called predicate functions.

{% highlight scala %}
scala> numbers.filter((i: Int) => i % 2 == 0)
res0: List[Int] = List(2, 4)
{% endhighlight %}

{% highlight scala %}
scala> def isEven(i: Int): Boolean = i % 2 == 0
isEven: (i: Int)Boolean

scala> numbers.filter(isEven _)
res2: List[Int] = List(2, 4)
{% endhighlight %}

h4. zip

zip aggregates the contents of two lists into a single list of pairs.

{% highlight scala %}
scala> List(1, 2, 3).zip(List("a", "b", "c"))
res0: List[(Int, String)] = List((1,a), (2,b), (3,c))
{% endhighlight %}

h4. partition

partition splits a list based on where it falls with respect to a predicate function.

{% highlight scala %}
scala> List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).partition((i: Int) => i > 5)
res0: (List[Int], List[Int]) = (List(6, 7, 8, 9, 10),List(1, 2, 3, 4, 5))
{% endhighlight %}

h4. find

find returns the first element of a collection that matches a predicate function.

{% highlight scala %}
scala> numbers.find((i: Int) => i > 5)
res0: Option[Int] = Some(6)
{% endhighlight %}

h4. drop & dropWhile

Drops the first i elements

{% highlight scala %}
scala> numbers.drop(5)
res0: List[Int] = List(6, 7, 8, 9, 10)
{% endhighlight %}

dropWhile removes elements that don't match a predicate function.  Here we can re-implement drop.

{% highlight scala %}
scala> numbers.dropWhile((i: Int) => i < 6)
res0: List[Int] = List(6, 7, 8, 9, 10)
{% endhighlight %}

h4. foldLeft

{% highlight scala %}
scala> numbers.foldLeft(0)((m: Int, n: Int) => m + n)
res0: Int = 55
{% endhighlight %}

0 is the starting value (Remember that numbers is a List[Int]), and m
acts as an accumulator.

Seen visually:

{% highlight scala %}
scala> numbers.foldLeft(0) { (m: Int, n: Int) => println("m: " + m + " n: " + n); m + n }
m: 0 n: 1
m: 1 n: 2
m: 3 n: 3
m: 6 n: 4
m: 10 n: 5
m: 15 n: 6
m: 21 n: 7
m: 28 n: 8
m: 36 n: 9
m: 45 n: 10
res0: Int = 55
{% endhighlight %}

h5. foldRight

Is the same as foldLeft except it runs in the opposite direction.

{% highlight scala %}
scala> numbers.foldRight(0)((m: Int, n: Int) => println("m: " + m + " n: " + n); m + n)
m: 10 n: 0
m: 9 n: 10
m: 8 n: 19
m: 7 n: 27
m: 6 n: 34
m: 5 n: 40
m: 4 n: 45
m: 3 n: 49
m: 2 n: 52
m: 1 n: 54
res0: Int = 55
{% endhighlight %}

h5. flatten

flatten collapses one level of nested structure.

{% highlight scala %}
scala> List(List(1, 2), List(3, 4)).flatten
res0: List[Int] = List(1, 2, 3, 4)
{% endhighlight %}

h5. flatMap

flatMap is a frequently used combinator that combines mapping and flattening. flatMap takes a function that works on the nested lists and then concatenates the results back together.

{% highlight scala %}
scala> val nestedNumbers = List(List(1, 2), List(3, 4))
nestedNumbers: List[List[Int]] = List(List(1, 2), List(3, 4))

scala> nestedNumbers.flatMap(x => x.map(_ * 2))
res0: List[Int] = List(2, 4, 6, 8)
{% endhighlight %}

Think of it as short-hand for mapping and then flattening:

{% highlight scala %}
scala> nestedNumbers.map(x: List[Int] => x.map(_ * 2)).flatten
res1: List[Int] = List(2, 4, 6, 8)
{% endhighlight %}

that example calling map and then flatten is an example of the "combinator"-like nature of these functions.


h4. Generalized functional combinators

Now we've learned a grab-bag of functions for working with collections.

What we'd like is to be able to write our own functional combinators.

Interestingly, every functional combinator shown above can be written on top of fold.  Let's see some examples.

{% highlight scala %}
def ourMap(numbers: List[Int], fn: Int => Int): List[Int] = {
  numbers.foldRight(List[Int]()) { (x: Int, xs: List[Int]) =>
    fn(x) :: xs
  }
}

scala> ourMap(numbers, timesTwo(_))
res0: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
{% endhighlight %}

Why <tt>List[Int]()</tt>? Scala wasn't smart enough to realize that you wanted an empty list of Ints to accumulate into.

h3. Map?

All of the functional combinators shown work on Maps, too.  Maps can be thought of as a list of pairs so the functions you write work on a pair of the keys and values in the Map.

{% highlight scala %}
scala> val extensions = Map("steve" -> 100, "bob" -> 101, "joe" -> 201)
extensions: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101), (joe,201))
{% endhighlight %}

now filter out every entry who's phone extension is lower than 200.

{% highlight scala %}
scala> extensions.filter((namePhone: (String, Int)) => namePhone._2 < 200)
res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101))
{% endhighlight %}

Because it gives you a tuple, you have to pull out the keys and values with their positional accessors. Yuck!

Lucky us, we can actually use a pattern match to extract the key and value nicely.

{% highlight scala %}
scala> extensions.filter(case (name, extension) => extension < 200)
res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101))
{% endhighlight %}

Why does this work? Why can you pass in a partial pattern match?

Stay tuned for next week!
