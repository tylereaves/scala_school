---
permalink: specs.html
title: Testing with specs
layout: post
desc: Write tests with Specs, a BDD testing framework for Scala
---

This lesson covers testing with Specs, a BDD Framework for Scala.

* Contexts
** nested examples
* Setup
** doFirst
** doBefore
** doAfter
* Matchers
** mustEqual
** contains
** sameSize?
** Write your own
* Mocks
* Spies
* How does this work?
** What if we don't like the implicits?

h2. extends Specifcation

Let's just jump in.

{% highlight scala %}
import org.specs._

object ArithmeticSpec extends Specification {
  "Arithmetic" should {
    "add two numbers" in {
      1 + 1 mustEqual 2
    }
    "add three numbers" in {
      1 + 1 + 1 mustEqual 3
    }
  }
}
{% endhighlight %}

h2. Let's break this down


*Arithmetic* is the *System Under Specification*

*add* is a context.

*add two numbers* and *add three numbers* are examples.

@mustEqual@ indicates an *expectation*

@1 mustEqual 1@ is a common placeholder *expectation* before you start writing real tests.  All examples should have at least one expectation.


h2. Duplication

Notice how two tests both have @add@ in their name?  We can get rid of that by *nesting* expectations.

{% highlight scala %}
import org.specs._

object ArithmeticSpec extends Specification {
  "Arithmetic" should {
    "add" in {
      "two numbers" in {
        1 + 1 mustEqual 2
      }
      "three numbers" in {
        1 + 1 + 1 mustEqual 3
      }
    }
  }
}
{% endhighlight %}

h2. Execution Model

{% highlight scala %}
object ExecSpec extends Specification {
  "Mutations are isolated" should {
    var x = 0
    "x equals 1 if we set it." in {
      x = 1
      x mustEqual 1
    }
    "x is the default value if we don't change it" in {
      x mustEqual 0
    }
  }
}
{% endhighlight %}

h2. Setup

h3. doBefore & doAfter

{% highlight scala %}
"my system" should {
  doBefore { resetTheSystem() /** user-defined reset function */ }
  "mess up the system" in {...}
  "and again" in {...}
  doAfter { cleanThingsUp() }
}
{% endhighlight %}

*NOTE* @doBefore@/@doAfter@ are only run on leaf examples.

h3. doFirst & doLast

@doFirst@/@doLast@ is for single-time setup. (need example, I don't use this)

{% highlight scala %}
"Foo" should {
  doFirst { openTheCurtains() }
  "test stateless methods" in {...}
  "test other stateless methods" in {...}
  doLast { closeTheCurtains() }
}
{% endhighlight %}

h2. Matchers

You have data, you want to make sure it's right.

Let's tour the most commonly used matchers.

"Matchers Guide":http://code.google.com/p/specs/wiki/MatchersGuide

h3. mustEqual

We've seen several examples of mustEqual already.

{% highlight scala %}
1 mustEqual 1

"a" mustEqual "a"
{% endhighlight %}

Reference equality, value equality.

h3. elements in a Sequence

{% highlight scala %}
val numbers = List(1, 2, 3)

numbers must contain(1)
numbers must not contain(4)

numbers must containAll(List(1, 2, 3))
numbers must containInOrder(List(1, 2, 3))

List(1, List(2, 3, List(4)), 5) must haveTheSameElementsAs(List(5, List(List(4), 2, 3), 1))
{% endhighlight %}


h3. Items in a Map

{% highlight scala %}
map must haveKey(k)
map must notHaveKey(k)

map must haveValue(v)
map must notHaveValue(v)
{% endhighlight %}

h3. Numbers

{% highlight scala %}
a must beGreaterThan(b)
a must beGreaterThanOrEqualTo(b)

a must beLessThan(b)
a must beLessThanOrEqualTo(b)

a must beCloseTo(b, delta)
{% endhighlight %}


h3. Options

{% highlight scala %}
a must beNone

a must beSome[Type]

a must beSomething

a must beSome(value)
{% endhighlight %}

h3. throwA

{% highlight scala %}
a must throwA[WhateverException]
{% endhighlight %}

This is shorter than a try catch with a fail in the body.

You can also expect a specific message

{% highlight scala %}
a must throwA(WhateverException("message"))
{% endhighlight %}

You can also match on the exception:

{% highlight scala %}
a must throwA(new Exception) like {
  case Exception(m) => m.startsWith("bad")
}
{% endhighlight %}


h3. Write your own Matchers

h4. As a val
{% highlight scala %}
import org.specs.matcher.Matcher
{% endhighlight %}
{% highlight scala %}
"A matcher" should {
  "be created as a val" in {
    val beEven = new Matcher[Int] {
      def apply(n: => Int) = {
        (n % 2 == 0, "%d is even".format(n), "%d is odd".format(n))
      }
    }
    2 must beEven
  }
}
{% endhighlight %}

The contract is to return a tuple containing whether the expectation is true, and a message for when it is and isn't true.

h4. As a case class

{% highlight scala %}
case class beEven(b: Int) extends Matcher[Int]() {
  def apply(n: => Int) =  (n % 2 == 0, "%d is even".format(n), "%d is odd".format(n))
}
{% endhighlight %}

Using a case class makes it more shareable.

h3. Mocks

{% highlight scala %}
import org.specs.Specification
import org.specs.mock.Mockito

class Foo[T] {
  def get(i: Int): T
}

object MockExampleSpec extends Specification with Mockito {
  val m = mock[Foo[String]]

  m.get(0) returns "one"

  m.get(0)

  there was one(m).get(0)

  there was no(m).get(1)
}
{% endhighlight %}


h3. Spies

Spies can also be used in order to do some "partial mocking" of real objects:

{% highlight scala %}
val list = new LinkedList[String]
val spiedList = spy(list)

// methods can be stubbed on a spy
spiedList.size returns 100

// other methods can also be used
spiedList.add("one")
spiedList.add("two")

// and verification can happen on a spy
there was one(spiedList).add("one")
{% endhighlight %}

However, working with spies can be tricky:

{% highlight scala %}
// if the list is empty, this will throws an IndexOutOfBoundsException
spiedList.get(0) returns "one"
{% endhighlight %}

@doReturn@ must be used in that case:

{% highlight scala %}
doReturn("one").when(spiedList).get(0)
{% endhighlight %}


h3. Run individual specs in sbt


{% highlight scala %}
> test-only com.twitter.yourservice.UserSpec
{% endhighlight %}

Will run just that spec.


{% highlight scala %}
> ~ test-only com.twitter.yourservice.UserSpec
{% endhighlight %}

Will run that test in a loop, with each file modification triggering a
test run.
